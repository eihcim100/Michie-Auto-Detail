# admin_app.py

from flask import Flask, request, jsonify
from flask_cors import CORS
import os
import psycopg2
import psycopg2.extras 
from bcrypt import hashpw, gensalt, checkpw
import sys
import traceback
import json 
import uuid # Ensure uuid is imported
import httpx 
import re 
from datetime import datetime, timedelta
import pytz # Import pytz for timezone handling

app = Flask(__name__)

# --- Configuration ---
ADMIN_API_KEY = os.environ.get('ADMIN_API_KEY')
DATABASE_URL = os.environ.get('DATABASE_URL')
PIPEDRIVE_API_TOKEN = os.environ.get('PIPEDRIVE_API_TOKEN')
PIPEDRIVE_COMPANY_DOMAIN = os.environ.get('PIPEDRIVE_COMPANY_DOMAIN')
PIPEDRIVE_BASE_URL = f"https://{PIPEDRIVE_COMPANY_DOMAIN}.pipedrive.com/api/v1" if PIPEDRIVE_COMPANY_DOMAIN else None

# --- Pipedrive Custom Field API Keys ---
FIELD_KEYS = {
    "VEHICLE_YEAR": "56c022b76dcf2d85030ec328aa5ccbb455c30540",
    "VEHICLE_MAKE": "0182a3501330385f0164ad94f8627861d2e69024",
    "VEHICLE_MODEL": "d278b92e98559a495f225ac4dff1084b0305cb4b",
    "SERVICE_ADDRESS": "3fd7cb63ede74d310c9a9b9c047021b12a9fa8b6",
    "APPOINTMENT_DATE": "f3301c53ce79896154cc15cc2bad3cf5a79252c9",
    "APPOINTMENT_TIME": "0f2af5bac442a73cc054dc9e74a38f1cf3e8e90a",
    "PAY": "df0924dde48a9f24dc9dfc6e741b26555c097be4",
    "INSTALLMENT_1_DATE": "cdfbc483d18b7a4b67ae7785b9cdd72cdf33bced",
    "INSTALLMENT_2_DATE": "9a903dece6dd10aefa05178db5ef3259cab45b4e",
    "INSTALLMENT_3_DATE": "dbcd983b79990edd71d403627648365cc90117c6",
    "VEHICLE_2_DETAILS": "1fe9cd653ad3de948c9685153f0d469523aca13c",
    "PACKAGE_TYPE": "759b224c353b0136a161ff57097ba235c9115eed",  # Custom field for package type
    "PACKAGE_PRICE": "5c5ade54364ebfd1ebc2d1eb1425441e46e641e0",  # Custom field for package price
    "VEHICLE_1_UUID": "5ea831ebb0931443b5b817249eea4a8a737427bc", # New: Custom field for Primary Vehicle UUID
    "VEHICLE_2_UUID": "a3d9414797ab496ddcc9ccc42750340a46b86436"  # New: Custom field for Secondary Vehicle UUID
}

# --- CORS Configuration ---
CORS(app, resources={r"/*": {"origins": [
    "https://michie-detailing-admin.onrender.com", 
    "https://michieauto.com",                     
    "http://127.0.0.1:5500",                      
    "null"                                        
]}}, supports_credentials=True)


# --- Database Functions ---
def get_db_connection():
    if not DATABASE_URL: raise RuntimeError("DATABASE_URL is not set.")
    return psycopg2.connect(DATABASE_URL)

def init_db():
    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS customers (
                id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                full_name VARCHAR(255) NOT NULL,
                email VARCHAR(255) UNIQUE NOT NULL,
                phone VARCHAR(50),
                address TEXT,
                password_hash TEXT NOT NULL,
                zip_code VARCHAR(20),
                created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
            );
        """)
        
        cursor.execute("""
            ALTER TABLE customers
            ADD COLUMN IF NOT EXISTS pipedrive_person_id INTEGER;
        """)

        cursor.execute("""
            CREATE TABLE IF NOT EXISTS vehicles (
                id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                customer_id UUID NOT NULL REFERENCES customers(id) ON DELETE CASCADE,
                year VARCHAR(4),
                make VARCHAR(255),
                model VARCHAR(255),
                is_primary BOOLEAN NOT NULL DEFAULT FALSE,
                created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
            );
        """)
        conn.commit()
        print("--- Database tables checked/created successfully. ---")
    except Exception as e:
        print(f"ERROR: Database initialization failed: {e}")
    finally:
        if conn: conn.close()

def find_or_create_pipedrive_person_sync(client, cursor, customer):
    if customer.get('pipedrive_person_id'):
        return customer['pipedrive_person_id']
    
    search_res = client.get(
        f"{PIPEDRIVE_BASE_URL}/persons/search",
        params={"term": customer['email'], "fields": "email", "exact_match": True, "api_token": PIPEDRIVE_API_TOKEN}
    )
    search_res.raise_for_status()
    search_data = search_res.json()

    if search_data.get("data", {}).get("items"):
        person_id = search_data["data"]["items"][0]["item"]["id"]
        cursor.execute("UPDATE customers SET pipedrive_person_id = %s WHERE id = %s", (person_id, str(customer['id']))) # Convert customer['id'] to string
        return person_id
    else:
        create_res = client.post(
            f"{PIPEDRIVE_BASE_URL}/persons",
            params={"api_token": PIPEDRIVE_API_TOKEN},
            json={"name": customer['full_name'], "email": [customer['email']], "phone": [customer.get('phone')]}
        )
        create_res.raise_for_status()
        person_id = create_res.json().get("data", {}).get("id")
        if person_id:
            cursor.execute("UPDATE customers SET pipedrive_person_id = %s WHERE id = %s", (person_id, str(customer['id']))) # Convert customer['id'] to string
        return person_id


# --- CUSTOMER PORTAL FUNCTIONS ---
@app.route('/customer/login', methods=['POST'])
def customer_login():
    conn = None
    try:
        data = request.get_json()
        email, password = data.get('email'), data.get('password')
        if not email or not password: return jsonify({"message": "Email and password are required."}), 400
        conn = get_db_connection()
        cursor = conn.cursor(cursor_factory=psycopg2.extras.DictCursor)
        cursor.execute("SELECT id, email, password_hash, full_name FROM customers WHERE email = %s", (email,))
        customer = cursor.fetchone()
        if customer and checkpw(password.encode('utf-8'), customer['password_hash'].encode('utf-8')):
            return jsonify({"message": "Login successful!", "token": str(customer['id']), "full_name": customer['full_name']}), 200
        else:
            return jsonify({"message": "Invalid email or password."}), 401
    except Exception as e:
        print(f"ERROR: Customer login failed: {e}")
        return jsonify({"message": "A network error occurred during login."}), 500
    finally:
        if conn: conn.close()

@app.route('/customer/data', methods=['GET'])
def get_customer_data():
    conn = None
    try:
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith('Bearer '):
            return jsonify({"message": "Authorization token is missing."}), 401
        
        customer_id = auth_header.split(' ')[1]
        conn = get_db_connection()
        cursor = conn.cursor(cursor_factory=psycopg2.extras.DictCursor)

        cursor.execute("SELECT * FROM customers WHERE id = %s", (customer_id,))
        customer = cursor.fetchone()
        if not customer:
            return jsonify({"message": "Customer not found."}), 404

        cursor.execute("SELECT id, year, make, model, is_primary FROM vehicles WHERE customer_id = %s ORDER BY is_primary DESC, created_at ASC", (customer_id,))
        vehicles = [dict(row) for row in cursor.fetchall()]
        
        upcoming_appointments = []
        past_appointments = []
        
        # Define CST timezone
        cst_timezone = pytz.timezone('America/Chicago') # CST is America/Chicago
        
        try:
            if customer.get('pipedrive_person_id') and all([PIPEDRIVE_API_TOKEN, PIPEDRIVE_BASE_URL]):
                with httpx.Client(timeout=10.0) as client:
                    # Fetch ALL deals for the person, regardless of status
                    deals_res = client.get(
                        f"{PIPEDRIVE_BASE_URL}/persons/{customer['pipedrive_person_id']}/deals",
                        params={"api_token": PIPEDRIVE_API_TOKEN, "limit": 500} # Increased limit to fetch more deals
                    )
                    deals_res.raise_for_status()
                    deals = deals_res.json().get("data", [])
                    
                    if deals:
                        # Get current time in CST
                        now_cst = datetime.now(cst_timezone)

                        for deal in deals:
                            appt_date_str = deal.get(FIELD_KEYS["APPOINTMENT_DATE"])
                            appt_time_str = deal.get(FIELD_KEYS["APPOINTMENT_TIME"])
                            package_type = deal.get(FIELD_KEYS["PACKAGE_TYPE"], "N/A") 
                            package_price = deal.get(FIELD_KEYS["PACKAGE_PRICE"]) 
                            
                            # Determine the correct vehicle_id (database UUID) from Pipedrive deal
                            # Check if either Vehicle 1 UUID or Vehicle 2 UUID field is populated
                            vehicle_id_from_deal = None
                            if deal.get(FIELD_KEYS["VEHICLE_1_UUID"]):
                                vehicle_id_from_deal = deal.get(FIELD_KEYS["VEHICLE_1_UUID"])
                            elif deal.get(FIELD_KEYS["VEHICLE_2_UUID"]):
                                vehicle_id_from_deal = deal.get(FIELD_KEYS["VEHICLE_2_UUID"])
                            
                            if appt_date_str and appt_time_str:
                                try:
                                    # Combine date and time into a datetime object
                                    # Use '%Y-%m-%d %H:%M:%S' to handle times with seconds
                                    appointment_datetime_naive = datetime.strptime(f"{appt_date_str} {appt_time_str}", '%Y-%m-%d %H:%M:%S')
                                    appointment_datetime_cst = cst_timezone.localize(appointment_datetime_naive)

                                    # Calculate the "display until" time (1 hour after appointment)
                                    display_until_time_cst = appointment_datetime_cst + timedelta(hours=1)

                                    appointment_info = {
                                        "title": deal.get('title'), # Use the actual deal title
                                        "date": appt_date_str,
                                        "time": appt_time_str, 
                                        "status": deal.get("status"),
                                        "package_type": package_type, # Include package type
                                        "package_price": package_price, # Include package price
                                        "vehicle_id": vehicle_id_from_deal # This will now be the actual database UUID
                                    }

                                    # Check if the appointment is upcoming (current CST time is before display_until_time_cst)
                                    if now_cst < display_until_time_cst:
                                        upcoming_appointments.append(appointment_info)
                                    else:
                                        past_appointments.append(appointment_info)
                                except ValueError as ve:
                                    print(f"WARNING: Could not parse appointment date/time for deal {deal.get('id')}: {appt_date_str} {appt_time_str}. Error: {ve}")
                                    # If parsing fails, treat as past or skip, depending on desired behavior.
                                    # For now, adding to past if parsing fails to avoid missing data.
                                    past_appointments.append({
                                        "title": deal.get('title'), 
                                        "date": appt_date_str if appt_date_str else "N/A",
                                        "time": appt_time_str if appt_time_str else "N/A", 
                                        "status": deal.get("status"),
                                        "package_type": package_type,
                                        "package_price": package_price,
                                        "vehicle_id": vehicle_id_from_deal,
                                        "note": "Date/Time parsing error"
                                    })
                            else:
                                # If date or time is missing, it cannot be an upcoming appointment.
                                # Add to past appointments with a note.
                                past_appointments.append({
                                    "title": deal.get('title'), 
                                    "date": appt_date_str if appt_date_str else "N/A",
                                    "time": appt_time_str if appt_time_str else "N/A", 
                                    "status": deal.get("status"),
                                    "package_type": package_type,
                                    "package_price": package_price,
                                    "vehicle_id": vehicle_id_from_deal,
                                    "note": "Missing date or time"
                                })

        except Exception as e:
            print(f"CRITICAL: Could not fetch deals from Pipedrive, but serving data anyway. Error: {e}")
        
        response_data = {
            "full_name": customer['full_name'],
            "address": customer['address'],
            "vehicles": vehicles,
            "upcoming_appointments": sorted(upcoming_appointments, key=lambda x: (x['date'], x['time'] or '00:00')),
            "past_appointments": sorted(past_appointments, key=lambda x: (x['date'], x['time'] or '00:00'), reverse=True)
        }
        return jsonify(response_data), 200
    except Exception as e:
        print(f"ERROR: Failed to fetch customer data: {e}")
        traceback.print_exc()
        return jsonify({"message": "An error occurred while fetching data."}), 500
    finally:
        if conn: conn.close()

@app.route('/customer/address', methods=['PUT'])
def update_customer_address():
    conn = None
    try:
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith('Bearer '):
            return jsonify({"message": "Authorization token is missing."}), 401
        
        customer_id = auth_header.split(' ')[1]
        data = request.get_json()
        new_address = data.get('address')
        
        if not new_address:
            return jsonify({"message": "New address is required."}), 400

        conn = get_db_connection()
        cursor = conn.cursor()
        
        # Update address in customers table
        cursor.execute("UPDATE customers SET address = %s WHERE id = %s", (new_address, customer_id,))
        
        # In Pipedrive, address is typically associated with deals or custom fields on persons/organizations.
        # We are not attempting to update a generic 'address' field on the Pipedrive Person object here,
        # as it's not a standard field. The 'SERVICE_ADDRESS' custom field will be populated when deals are created.
        
        conn.commit()
        print(f"Address updated for customer {customer_id} to {new_address}") # Added logging
        return jsonify({"message": "Address updated successfully!"}), 200
    except Exception as e:
        if conn: conn.rollback()
        print(f"ERROR: Failed to update address: {e}")
        traceback.print_exc()
        return jsonify({"message": "An error occurred while updating the address."}), 500
    finally:
        if conn: conn.close()

@app.route('/customer/vehicle/<uuid:vehicle_id>', methods=['PUT'])
def update_vehicle(vehicle_id):
    conn = None
    try:
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith('Bearer '):
            return jsonify({"message": "Authorization token is missing."}), 401
        
        customer_id = auth_header.split(' ')[1]
        data = request.get_json()
        year, make, model = data.get('year'), data.get('make'), data.get('model')

        if not all([year, make, model]):
            return jsonify({"message": "Year, make, and model are required."}), 400

        conn = get_db_connection()
        cursor = conn.cursor()

        # Verify the vehicle belongs to the authenticated customer
        # Convert vehicle_id to string before passing to cursor.execute
        cursor.execute("SELECT id FROM vehicles WHERE id = %s AND customer_id = %s", (str(vehicle_id), customer_id,))
        if not cursor.fetchone():
            return jsonify({"message": "Vehicle not found or does not belong to you."}), 404

        # Convert vehicle_id to string before passing to cursor.execute
        cursor.execute(
            "UPDATE vehicles SET year = %s, make = %s, model = %s WHERE id = %s",
            (year, make, model, str(vehicle_id))
        )
        conn.commit()
        print(f"Vehicle {vehicle_id} updated for customer {customer_id}: Year={year}, Make={make}, Model={model}") # Added logging
        return jsonify({"message": "Vehicle updated successfully!"}), 200
    except Exception as e:
        if conn: conn.rollback()
        print(f"ERROR: Failed to update vehicle: {e}")
        traceback.print_exc()
        return jsonify({"message": "An error occurred while updating the vehicle."}), 500
    finally:
        if conn: conn.close()

@app.route('/customer/vehicle/<uuid:vehicle_id>', methods=['DELETE'])
def delete_vehicle(vehicle_id):
    conn = None
    try:
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith('Bearer '):
            return jsonify({"message": "Authorization token is missing."}), 401
        
        customer_id = auth_header.split(' ')[1]

        conn = get_db_connection()
        cursor = conn.cursor()

        # Check if the vehicle belongs to the customer
        # Convert vehicle_id to string before passing to cursor.execute
        cursor.execute("SELECT customer_id FROM vehicles WHERE id = %s", (str(vehicle_id),))
        vehicle_owner_id = cursor.fetchone()

        if not vehicle_owner_id or str(vehicle_owner_id[0]) != customer_id:
            return jsonify({"message": "Vehicle not found or does not belong to you."}), 404

        # Prevent deleting the last vehicle if it's primary, or if it's the only vehicle
        cursor.execute("SELECT COUNT(*) FROM vehicles WHERE customer_id = %s", (customer_id,))
        vehicle_count = cursor.fetchone()[0]

        # Convert vehicle_id to string before passing to cursor.execute
        cursor.execute("SELECT is_primary FROM vehicles WHERE id = %s", (str(vehicle_id),))
        is_primary = cursor.fetchone()[0]

        if vehicle_count == 1:
            return jsonify({"message": "Cannot delete your only vehicle. Please add another vehicle first if you wish to change your primary."}), 400
        
        if is_primary:
            # If deleting primary, make the other vehicle primary if exists
            cursor.execute("""
                UPDATE vehicles
                SET is_primary = TRUE
                WHERE customer_id = %s AND id != %s
            """, (customer_id, str(vehicle_id))) # Convert vehicle_id to string
            print(f"Set another vehicle as primary for customer {customer_id}")

        # Convert vehicle_id to string before passing to cursor.execute
        cursor.execute("DELETE FROM vehicles WHERE id = %s AND customer_id = %s", (str(vehicle_id), customer_id,))
        conn.commit()
        print(f"Vehicle {vehicle_id} deleted for customer {customer_id}") # Added logging
        return jsonify({"message": "Vehicle deleted successfully!"}), 200
    except Exception as e:
        if conn: conn.rollback()
        print(f"ERROR: Failed to delete vehicle: {e}")
        traceback.print_exc()
        return jsonify({"message": "An error occurred while deleting the vehicle."}), 500
    finally:
        if conn: conn.close()

@app.route('/customer/vehicle', methods=['POST'])
def add_vehicle():
    conn = None
    try:
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith('Bearer '):
            return jsonify({"message": "Authorization token is missing."}), 401
        
        customer_id = auth_header.split(' ')[1]
        data = request.get_json()
        year, make, model = data.get('year'), data.get('make'), data.get('model')

        if not all([year, make, model]):
            return jsonify({"message": "Year, make, and model are required."}), 400

        conn = get_db_connection()
        cursor = conn.cursor()

        # Check existing vehicle count for the customer
        cursor.execute("SELECT COUNT(*) FROM vehicles WHERE customer_id = %s", (customer_id,))
        vehicle_count = cursor.fetchone()[0]

        if vehicle_count >= 2:
            return jsonify({"message": "You can only have up to two vehicles registered."}), 400

        is_primary = False
        if vehicle_count == 0: # If this is the first vehicle, make it primary
            is_primary = True

        cursor.execute(
            "INSERT INTO vehicles (customer_id, year, make, model, is_primary) VALUES (%s, %s, %s, %s, %s) RETURNING id",
            (customer_id, year, make, model, is_primary)
        )
        new_vehicle_id = cursor.fetchone()[0]
        conn.commit()
        print(f"Vehicle added for customer {customer_id}: ID={new_vehicle_id}, Year={year}, Make={make}, Model={model}, IsPrimary={is_primary}") # Added logging
        return jsonify({"message": "Vehicle added successfully!", "vehicle_id": str(new_vehicle_id)}), 201
    except Exception as e:
        if conn: conn.rollback()
        print(f"ERROR: Failed to add vehicle: {e}")
        traceback.print_exc()
        return jsonify({"message": "An error occurred while adding the vehicle."}), 500
    finally:
        if conn: conn.close()

@app.route('/customer/appointment', methods=['POST'])
def book_appointment():
    conn = None
    try:
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith('Bearer '): return jsonify({"message": "Authorization token is missing."}), 401
        customer_id = auth_header.split(' ')[1]
        
        data = request.get_json()
        vehicle_id, booking_date, booking_time = data.get('vehicle_id'), data.get('date'), data.get('time')
        package_type, package_price = data.get('package_type'), data.get('package_price') # Get new fields
        deal_name = data.get('deal_name') # Get the new deal_name field
        
        if not all([vehicle_id, booking_date, booking_time, package_type, package_price, deal_name]): return jsonify({"message": "Vehicle, date, time, package type, package price, and deal name are required."}), 400

        conn = get_db_connection()
        cursor = conn.cursor(cursor_factory=psycopg2.extras.DictCursor)
        create_pipedrive_deal(cursor, customer_id, vehicle_id, booking_date, booking_time, package_type, package_price, deal_name, financing=False)
        
        conn.commit()
        return jsonify({"message": "Appointment booked successfully!"}), 201
    except Exception as e:
        if conn: conn.rollback()
        print(f"ERROR: Failed to book appointment: {e}")
        traceback.print_exc()
        return jsonify({"message": "An error occurred while booking the appointment."}), 500
    finally:
        if conn: conn.close()

@app.route('/customer/appointment/financing', methods=['POST'])
def book_financing_appointment():
    conn = None
    try:
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith('Bearer '): return jsonify({"message": "Authorization token is missing."}), 401
        customer_id = auth_header.split(' ')[1]
        
        data = request.get_json()
        vehicle_id, booking_date, booking_time = data.get('vehicle_id'), data.get('date'), data.get('time')
        package_type, package_price = data.get('package_type'), data.get('package_price') # Get new fields
        deal_name = data.get('deal_name') # Get the new deal_name field

        if not all([vehicle_id, booking_date, booking_time, package_type, package_price, deal_name]): return jsonify({"message": "Vehicle, date, time, package type, package price, and deal name are required."}), 400

        conn = get_db_connection()
        cursor = conn.cursor(cursor_factory=psycopg2.extras.DictCursor)
        create_pipedrive_deal(cursor, customer_id, vehicle_id, booking_date, booking_time, package_type, package_price, deal_name, financing=True)
        
        conn.commit()
        return jsonify({"message": "Financed appointment booked successfully!"}), 201
    except Exception as e:
        if conn: conn.rollback()
        print(f"ERROR: Failed to book financing appointment: {e}")
        traceback.print_exc()
        return jsonify({"message": "An error occurred while booking the appointment."}), 500
    finally:
        if conn: conn.close()
        
# --- SCRIPT EXECUTION ---
if __name__ == '__main__':
    port = int(os.environ.get("PORT", 5001))
    app.run(host='0.0.0.0', port=port)
else:
    init_db()
